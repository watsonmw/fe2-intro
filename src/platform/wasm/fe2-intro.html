<!doctype html>
<html lang="en-us">
<head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="manifest" href="manifest.json">
    <title>Frontier Elite II - Intro</title>
    <style>
        body { background-color: #080808; margin: 0; }
        canvas.wasm-canvas { position: fixed; border: 0 none; display: block; }
        canvas.wasm-canvas:focus-visible { outline: none; }
        button {
            float: right;
            display: block;
            box-sizing: border-box;
            margin: 6px;
            padding: 3px 3px 0 3px;
            border: 0;
            background: none;
        }
        button:hover {
            padding: 2px 2px 0 2px;
            border: 1px solid black;
            outline: 1px solid white;
        }
        div.overlay { position: fixed; z-index: 1; width: 100%; opacity: 0.0; transition: .4s ease; }
        div.loading-overlay { position: fixed; z-index: 1; width: 100%; height: 100%; }
    </style>
</head>
<body>
<canvas class="wasm-canvas" id="app-fe2-intro" oncontextmenu="event.preventDefault()" tabindex=-1></canvas>
<div class="overlay" id="overlay-controls">
    <button id="exitFullscreenButton">
        <svg width=32 height=32>
            <polygon fill="white" stroke="black" points="23.33 20.5 28.5 20.5 28.5 16.5 16.5 16.5 16.5 28.5 20.5 28.5 20.5 23.33 28.17 31 31 31 31 28.17 23.33 20.5"></polygon>
            <polygon fill="white" stroke="black" points="11.5 8.67 3.83 1 1 1 1 3.83 8.67 11.5 3 11.5 3 15.5 15.5 15.5 15.5 3 11.5 3 11.5 8.67"></polygon>
        </svg>
    </button>
    <button id="fullscreen-button">
        <svg width=32 height=32>
            <polygon fill="white" stroke="black" points="27 18 27 24.17 19.41 16.59 16.59 19.41 24.17 27 18 27 18 31 31 31 31 18 27 18"></polygon>
            <polygon fill="white" stroke="black" points="14 5 14 1 1 1 1 14 5 14 5 7.83 12.34 15.16 15.16 12.34 7.83 5 14 5"></polygon>
        </svg>
    </button>
</div>
<div class="loading-overlay" id="loading-overlay">
    <div style="position: absolute; bottom: 0;"><p id="status" style="color:white;font-family: Geneva,monospace"></p></div>
</div>
<script type="module">
    async function init(elementId) {
        const canvas_element = document.getElementById(`app-${elementId}`);
        if (canvas_element === null) {
            return;
        }

        const canvas_ctx = canvas_element.getContext("2d");

        // const PlayerWap = (function () {
        //     function x() {
        //
        //     }
        //     return {'x': x};
        // });
        // const p = PlayerWap();

        const PlayerApp = (function() {
            let app = null;
            const memory = new WebAssembly.Memory({
                initial: 50,
                maximum: 200,
            });
            const memory_buffer = new Uint8Array(memory.buffer);
            const load_tasks = [];
            const loaded_files = {};

            function load_file(name) {
                return new Promise((ok, nope) => {
                    if (loaded_files.hasOwnProperty(name)) {
                        ok(loaded_files[name]);
                    } else {
                        fetch(name).then(resp => {
                            if (resp.ok) {
                                resp.arrayBuffer().then(arr => {
                                    loaded_files[name] = arr;
                                    ok(arr)
                                });
                            } else {
                                ok(null);
                            }
                        });
                    }
                });
            }

            const text_decoder = new TextDecoder();
            function wasm_string(str_offset, str_size) {
                if (!str_size || str_size <= 0) {
                    return "";
                }
                return text_decoder.decode(new Uint8Array(memory.buffer, str_offset, str_size));
            }

            function wasm_get_surface(surface_offset)
            {
                let offset = 0;
                const SURFACE_WIDTH_OFFSET = offset++;
                const SURFACE_HEIGHT_OFFSET = offset++;
                const SURFACE_PIXELS_OFFSET = offset++;
                const SURFACE_SIZE_TOTAL = offset;
                const surface_memory = new Uint32Array(memory.buffer, surface_offset, SURFACE_SIZE_TOTAL);
                return {
                    width: surface_memory[SURFACE_WIDTH_OFFSET],
                    height: surface_memory[SURFACE_HEIGHT_OFFSET],
                    pixels: surface_memory[SURFACE_PIXELS_OFFSET],
                };
            }

            function wasm_get_audio_buffer(buffer_offset)
            {
                let offset = 0;
                const AUDIO_SIZE_OFFSET = offset++;
                const AUDIO_LEFT_BUFFER = offset++;
                const AUDIO_RIGHT_BUFFER = offset++;
                const AUDIO_SIZE_TOTAL = offset;
                const audio_buffer = new Uint32Array(memory.buffer, buffer_offset, AUDIO_SIZE_TOTAL);
                return {
                    size: audio_buffer[AUDIO_SIZE_OFFSET],
                    buffer_left: audio_buffer[AUDIO_LEFT_BUFFER],
                    buffer_right: audio_buffer[AUDIO_RIGHT_BUFFER]
                };
            }

            let console_output_buffer = "";
            function WASM_PrintLine(index, size) {
                if (app) {
                    // let memory = app.instance.exports.memory;
                    console.log(console_output_buffer + wasm_string(index, size));
                    console_output_buffer = "";
                }
            }

            function WASM_Print(index, size) {
                if (app) {
                    console_output_buffer += wasm_string(index, size);
                    let j = 0;
                    while (true) {
                        let i = console_output_buffer.indexOf("\n", j);
                        if (i === -1) {
                            break;
                        }
                        let line = console_output_buffer.substring(j, i);
                        console.log(line, line.length);
                        j = i + 1;
                    }
                    console_output_buffer = console_output_buffer.substring(j)
                }
            }

            function WASM_FileGetSize(filePathBuf, filePathSize) {
                let filePath = wasm_string(filePathBuf, filePathSize);
                let r = loaded_files[filePath];
                if (r == null) {
                    return 0;
                } else {
                    console.log("WASM_FileGetSize", filePath, r.byteLength);
                    return r.byteLength;
                }
            }

            // size_t WASM_FileRead(const char* filePathBuf, u32 filePathSize, u8* dest, u32 offset, u32 readSize)
            function WASM_FileRead(filePathBuf, filePathSize, dest, offset, readSize) {
                let filePath = wasm_string(filePathBuf, filePathSize);
                console.log("WASM_FileRead", filePath, dest, offset, readSize);
                let file_array = loaded_files[filePath];
                let arr = memory_buffer.subarray(dest + offset, dest + offset + readSize);
                arr.set(new Uint8Array(file_array));
                return readSize;
            }

            let started = false;
            let paused = false;
            let debug = false;
            function current_timestamp_ms() {
                return window.performance.now();
            }

            function startRenderLoop() {
                const surface_offset = app.instance.exports.get_surface();
                const surface = wasm_get_surface(surface_offset);

                function renderFrame(timestamp) {
                    app.instance.exports.render(timestamp);
                    const image = new ImageData(
                        new Uint8ClampedArray(memory.buffer, surface.pixels, surface.width * surface.height * 4),
                        surface.width);
                    canvas_element.width = surface.width;
                    canvas_element.height = surface.height;
                    canvas_ctx.putImageData(image, 0, 0);
                }

                function frameLoop(timestamp) {
                    if (!paused) {
                        renderFrame(timestamp);
                    }
                    window.requestAnimationFrame(frameLoop);
                }

                function firstFrame(timestamp) {
                    renderFrame(timestamp);
                    window.requestAnimationFrame(frameLoop);
                }
                window.requestAnimationFrame(firstFrame);
            }

            async function loadWasm(filename) {
                let wasm_file = fetch(filename);
                load_tasks.push(wasm_file);
                for (const task of load_tasks) {
                    await task;
                }

                app = await WebAssembly.instantiateStreaming(wasm_file, {
                    env: {
                        memory: memory,
                        sin: Math.sin,
                        acos: Math.acos,
                        WASM_Print: WASM_Print,
                        WASM_PrintLine: WASM_PrintLine,
                        WASM_FileGetSize: WASM_FileGetSize,
                        WASM_FileRead: WASM_FileRead,
                    }
                });
                console.log(app.instance.exports);
                app.instance.exports.setup();
            }

            function fetchFiles(filenames) {
                for (const filename of filenames) {
                    load_tasks.push(load_file(filename));
                }
            }

            return {
                'fetchFiles': fetchFiles,
                'loadWasm': loadWasm,
                'startRenderLoop': startRenderLoop
            };
        });

        let resizeCanvas = (function() {
            let resizeCanvasFunc = function() {
                // Control the canvas location directly
                let width = document.documentElement.clientWidth;
                let height = document.documentElement.clientHeight;
                let ratioX = 9;
                let ratioY = 5;
                let newWidth = width;
                let newHeight = height;
                let marginX = 0;
                let marginY = 0;
                if (width * ratioY > height * ratioX) {
                    newWidth = (height * ratioX) / ratioY;
                    marginX = (width - newWidth) / 2;
                } else if (width * ratioY < height * ratioX) {
                    newHeight = (width * ratioY) / ratioX;
                    marginY = (height - newHeight) / 3;
                }
                canvas_element.style.left = Math.floor(marginX) + "px";
                canvas_element.style.top = Math.floor(marginY) + "px";
                canvas_element.style.width = Math.floor(newWidth) + "px";
                canvas_element.style.height = Math.floor(newHeight) + "px";
            }
            window.addEventListener('resize', resizeCanvasFunc, false);
            // Initial layout
            resizeCanvasFunc();
            // Final layout, if running in fullscreen mode as a fullscreen app on Chrome the view area is a bit small
            // the first time the screen is rendered.
            setTimeout(resizeCanvasFunc, 0);
            return resizeCanvasFunc;
        }());

        let OverlayControls = (function(){
            let docEl = window.document.documentElement;
            let doc = window.document;
            let getRequestFullScreenFunc = function() {
                return docEl.requestFullscreen || docEl.webkitRequestFullScreen || docEl.msRequestFullscreen;
            };
            let getExitFullScreenFunc = function() {
                return doc.exitFullscreen || doc.webkitExitFullscreen || doc.msExitFullscreen;
            };
            let isFullScreen = function() {
                return doc.fullscreenElement || doc.webkitFullscreenElement || doc.msFullscreenElement;
            };
            let isFullScreenEnabled = function() {
                return document.fullscreenEnabled || document.webkitFullscreenEnabled || document.msFullscreenEnabled;
            };
            let showElement = function(e) {
                if (e.style.display === "none") {
                    e.style.display = "block";
                }
            };
            let hideElement = function(e) {
                if (e.style.display !== "none") {
                    e.style.display = "none";
                }
            };
            let overlay = document.getElementById("overlay-controls");
            let fullscreenButton = document.getElementById("fullscreen-button");
            let exitFullscreenButton = document.getElementById("exitFullscreenButton");
            document.addEventListener("fullscreenchange", function () {
                if (isFullScreen()) {
                    hideElement(fullscreenButton);
                    showElement(exitFullscreenButton);
                } else {
                    hideElement(exitFullscreenButton);
                    showElement(fullscreenButton);
                }
                window.setTimeout(function () {
                    resizeCanvas();
                }, 0);
            }, false);
            let setup = function () {
                // If running as fullscreen app already, skip overlay setup
                if (overlay.style.display === 'none') {
                    return;
                }
                if (isFullScreenEnabled()) {
                    hideElement(exitFullscreenButton);
                    showElement(fullscreenButton);
                    let isHover = function(e) {
                        return !!(e.querySelector(":hover") || e.parentNode.querySelector(":hover") === e);
                    };
                    let hideTimer = null;
                    let showControls = function(checkHover) {
                        overlay.style.opacity = "0.9";
                        if (hideTimer) {
                            window.clearTimeout(hideTimer);
                        }
                        if (!checkHover || !isHover(overlay)) {
                            hideTimer = window.setTimeout(function() {
                                overlay.style.opacity = "0.0";
                                hideTimer = null;
                            }, 3000);
                        }
                    };
                    window.addEventListener("mousemove", () => { showControls(true) });
                    window.addEventListener("mousedown", () => { showControls(true) });
                    window.addEventListener("touchend", () => { showControls(false) });
                    showControls(false);
                    let toggleFullScreen = function() {
                        if (isFullScreen()) {
                            getExitFullScreenFunc().call(window.document);
                        } else {
                            getRequestFullScreenFunc().call(window.document.documentElement);
                        }
                        showControls(false);
                    };
                    fullscreenButton.addEventListener("click", toggleFullScreen, false);
                    exitFullscreenButton.addEventListener("click", toggleFullScreen, false);
                } else {
                    hideElement(exitFullscreenButton);
                    hideElement(fullscreenButton);
                }
            };
            return {
                setup: setup
            }
        })();

        let AudioPlayer = (function() {
            const sample_rate = 44100; // Hz
            let audio_context = null;
            let next_start_play_time = null;
            let audio_pause = true;
            let buffers = [null, null, null];
            let buffers_len = [null, null, null];
            let sources = [null, null, null];

            function get_audio_buffers(ticks) {
                const buffer_offset = app.instance.exports.audio_render(ticks);
                const audio_buffer = wasm_get_audio_buffer(buffer_offset);
                const audio_buffer_left_f32 = new Float32Array(memory.buffer, audio_buffer.buffer_left, audio_buffer.size);
                const audio_buffer_right_f32 = new Float32Array(memory.buffer, audio_buffer.buffer_right, audio_buffer.size);
                return [
                    audio_buffer_left_f32,
                    audio_buffer_right_f32,
                    audio_buffer.size
                ];
            }

            function fill_audio_buffer(buffer_index, refill_buffers) {
                // The rough idea here is that we buffer audio about a second ahead of schedule and rely on AudioContext's
                // internal timekeeping to keep it gap-less. playTime is the time in seconds that our stream is currently
                // buffered to.
                let buffer = buffers[buffer_index];
                if (buffer == null || refill_buffers) {
                    const frames = get_audio_buffers(1);
                    const frame_len = frames[2];
                    buffers_len[buffer_index] = frame_len

                    if (buffer == null) {
                        buffer = audio_context.createBuffer(2, frame_len, sample_rate);
                        buffers[buffer_index] = buffer;
                    }

                    buffer.copyToChannel(frames[0], 0);
                    buffer.copyToChannel(frames[1], 1);
                }

                // Play the buffer at some time in the future.
                const bsn = audio_context.createBufferSource();
                bsn.buffer = buffer;
                bsn.connect(audio_context.destination);
                // When a buffer is done playing, try to queue up
                // some more audio.
                bsn.onended = function() {
                    if (!audio_pause) {
                        fill_audio_buffer(buffer_index, true);
                    }
                };
                sources[buffer_index] = bsn
                bsn.start(next_start_play_time);
                // Advance our expected time.
                // (samples) / (samples per second) = seconds
                next_start_play_time += buffers_len[buffer_index] / sample_rate;
            }

            function fill_audio_buffers(refill_buffers) {
                fill_audio_buffer(0, refill_buffers);
                fill_audio_buffer(1, refill_buffers);
                fill_audio_buffer(2, refill_buffers);
            }

            function start_audio() {
                if (!audio_context) {
                    audio_context = new AudioContext();
                    next_start_play_time = audio_context.currentTime;
                    audio_pause = false;
                    fill_audio_buffers(true);
                }
            }

            function pause_audio() {
                audio_pause = true;
                for (let i = 0; i < 3; i++) {
                    let bsn = sources[i];
                    if (bsn) {
                        bsn.stop();
                    }
                    sources[0] = null;
                }
            }

            function resume_audio() {
                if (audio_pause) {
                    audio_pause = false;
                    if (audio_context) {
                        next_start_play_time = audio_context.currentTime;
                        fill_audio_buffers(false);
                    }
                }
            }

            return {
                start: start_audio,
                pause: pause_audio,
                resume: resume_audio
            }
        })();

        OverlayControls.setup();

        const player = PlayerApp();

        // Load wasm exec and data files in parallel
        player.fetchFiles(["game", "model-overrides-le.dat"]);
        await player.loadWasm("fe2-intro.wasm");

        let overlay = document.getElementById("loading-overlay");
        overlay.style.display = 'none';

        window.addEventListener("blur", (e) => {
            // paused = true;
            // app.instance.exports.set_paused(true, current_timestamp_ms());
            // AudioPlayer.pause();
        });
        window.addEventListener("focus", (e) => {
            // paused = false;
            // app.instance.exports.set_paused(false, current_timestamp_ms());
            // AudioPlayer.resume();
        });
        window.addEventListener("mousedown", (e) => {
            if (!started) {
                started = true;
                app.instance.exports.start_intro_after_interaction(current_timestamp_ms());
                AudioPlayer.start();
            }
        });
        window.addEventListener("keydown", (e) => {
            switch (e.key) {
                case '`':
                    debug = !debug;
                    app.instance.exports.set_debug_mode(debug);
                    break;
                case ' ':
                    paused = !paused;
                    app.instance.exports.set_paused(paused, current_timestamp_ms());
                    if (paused) {
                        AudioPlayer.pause();
                    } else {
                        AudioPlayer.resume();
                    }
                    break;
            }
        });

        player.startRenderLoop()
   }
    init("fe2-intro");
</script>
</body>
</html>
